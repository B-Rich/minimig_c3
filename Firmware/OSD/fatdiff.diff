33,36d32
< 2009-11-22  - modified FileSeek()
<             - added FileReadEx()
< 2009-12-15  - all entries are now sorted by name with extension
<             - directory short names are displayed with extensions
40c36
< #include <stdio.h>
---
> //#include <stdio.h>
43,47c39,40
< #include "mmc.h"
< #include "fat.h"
< #include "swap.h"
< 
< int tolower(int c);
---
> #include "MMC.h"
> #include "FAT.h"
53d45
< unsigned char fattype;              	// volume format 
67,70c59
< unsigned char sector_buffer[1024];       // sector buffer - room for two consecutive sectors...
< 
< struct PartitionEntry partitions[4];	// lbastart and sectors will be byteswapped as necessary
< int partitioncount;
---
> unsigned char sector_buffer[512];       // sector buffer
92,117d80
< 
< unsigned long SwapEndianL(unsigned long l)
< {
< 	unsigned char c[4];
< 	c[0] = (unsigned char)(l & 0xff);
< 	c[1] = (unsigned char)((l >> 8) & 0xff);
< 	c[2] = (unsigned char)((l >> 16) & 0xff);
< 	c[3] = (unsigned char)((l >> 24) & 0xff);
< 	return((c[0]<<24)+(c[1]<<16)+(c[2]<<8)+c[3]);
< }
< 
< void SwapPartitionBytes(int i)
< {
< 	// We don't bother to byteswap the CHS geometry fields since we don't use them.
< 	partitions[i].startlba=SwapEndianL(partitions[i].startlba);
< 	partitions[i].sectors=SwapEndianL(partitions[i].sectors);
< }
< 
< extern char BootPrint(const char *s);
< void bprintfl(const char *fmt,unsigned long l)
< {
< 	char s[64];
< 	sprintf(s,fmt,l);
< 	BootPrint(s);
< }
< 
126,183d88
< 	boot_sector=0;
< 	partitioncount=1;
< 
< 	// If we can identify a filesystem on block 0 we don't look for partitions
<     if (strncmp((const char*)&sector_buffer[0x36], "FAT16   ", 8)==0) // check for FAT16
< 		partitioncount=0;
<     if (strncmp((const char*)&sector_buffer[0x52], "FAT32   ", 8)==0) // check for FAT32
< 		partitioncount=0;
< 
< 	if(partitioncount)
< 	{
< 		// We have at least one partition, parse the MBR.
< 		struct MasterBootRecord *mbr=(struct MasterBootRecord *)sector_buffer;
< 		memcpy(&partitions[0],&mbr->Partition[0],sizeof(struct PartitionEntry));
< 		memcpy(&partitions[1],&mbr->Partition[1],sizeof(struct PartitionEntry));
< 		memcpy(&partitions[2],&mbr->Partition[2],sizeof(struct PartitionEntry));
< 		memcpy(&partitions[3],&mbr->Partition[3],sizeof(struct PartitionEntry));
< 
< 		switch(mbr->Signature)
< 		{
< 			case 0x55aa:	// Little-endian MBR on a big-endian system
< 				BootPrint("Swapping byte order of partition entries");
< 				SwapPartitionBytes(0);
< 				SwapPartitionBytes(1);
< 				SwapPartitionBytes(2);
< 				SwapPartitionBytes(3);
< 				// fall through...
< 			case 0xaa55:
< 				// get start of first partition
< 				boot_sector = partitions[0].startlba;
< 				bprintfl("Start: %ld\n",partitions[0].startlba);
< 				for(partitioncount=4;(partitions[partitioncount-1].sectors==0) && (partitioncount>1); --partitioncount)
< 					;
< 				bprintfl("PartitionCount: %ld\n",partitioncount);
< 				int i;
< 				for(i=0;i<partitioncount;++i)
< 				{
< 					bprintfl("Partition: %ld",i);
< 					bprintfl("  Start: %ld",partitions[i].startlba);
< 					bprintfl("  Size: %ld\n",partitions[i].sectors);
< 				}
< //				WaitTimer(5000);
< 				if (!MMC_Read(boot_sector, sector_buffer)) // read discriptor
< 				    return(0);
< 				BootPrint("Read boot sector from first partition\n");
< 				break;
< 			default:
< 				BootPrint("No partition signature found\n");
< 				break;
< 		}
< 	}
< 
<     if (strncmp((const char*)&sector_buffer[0x36], "FAT16   ", 8)==0) // check for FAT16
< 		fattype = 16;
< 
<     if (strncmp((const char*)&sector_buffer[0x52], "FAT32   ", 8)==0) // check for FAT32
< 		fattype = 32;
< 	
185c90
<     switch (fattype)
---
>     switch (sector_buffer[450])
187,202c92,108
< 		case 0:
< 		    printf("NONE");
< 		    break;
< 		case 12:
< 		    printf("FAT12");
< 		    break;
< 		case 16:
< 		    printf("FAT16");
< 		    break;
< 		case 32:
< 		    printf("FAT32");
< 		    fat32 = 1;
< 		    break;
< 		default:
< 		    printf("UNKNOWN");
< 		    break;
---
>     case 0x00:
>         printf("NONE");
>         break;
>     case 0x01:
>         printf("FAT12");
>         break;
>     case 0x04:
>     case 0x06:
>         printf("FAT16");
>         break;
>     case 0x0B:
>     case 0x0C:
>         printf("FAT32");
>         break;
>     default:
>         printf("UNKNOWN");
>         break;
206c112
<     if (fattype != 32 && fattype != 16) // first partition filesystem type: FAT16 or FAT32
---
>     if (sector_buffer[450] != 0x04 && sector_buffer[450] != 0x06 && sector_buffer[450] != 0x0B && sector_buffer[450] != 0x0C) // first partition filesystem type: FAT16
211a118,120
>     if (sector_buffer[450] == 0x0B || sector_buffer[450] == 0x0C)
>        fat32 = 1;
> 
215,216c124,134
< //    if (!MMC_Read(boot_sector, sector_buffer)) // read boot sector
< //        return(0);
---
>     // get start of first partition
>     boot_sector = sector_buffer[467];
>     boot_sector <<= 8;
>     boot_sector |= sector_buffer[466];
>     boot_sector <<= 8;
>     boot_sector |= sector_buffer[455];
>     boot_sector <<= 8;
>     boot_sector |= sector_buffer[454];
> 
>     if (!MMC_Read(boot_sector, sector_buffer)) // read boot sector
>         return(0);
285c203
< unsigned char FileOpen(fileTYPE *file, const char *name)
---
> unsigned char FileOpen(fileTYPE *file, char *name)
410c328
<         len = 11;
---
>         len = 8;
418c336
<         len = 11;
---
>         len = 8;
462c380
<     /*
---
> 
465c383
<     */
---
> 
541,548c459,466
<                 pEntry = (DIRENTRY*)sector_buffer;
< 				for (i = 0; i < 16; i++) 
< 				{
< 					if (pEntry->Attributes != ATTR_LFN)
< 					{
< 						pEntry->StartCluster = SwapBB(pEntry->StartCluster);
< 						pEntry->HighCluster = SwapBB(pEntry->HighCluster);
< 						pEntry->FileSize = SwapBBBB(pEntry->FileSize);
---
>                 pEntry = (DIRENTRY*)sector_buffer;
> 				for (i = 0; i < 16; i++) 
> 				{
> 					if (pEntry->Attributes != ATTR_LFN)
> 					{
> 						pEntry->StartCluster = SwapBB(pEntry->StartCluster);
> 						pEntry->HighCluster = SwapBB(pEntry->HighCluster);
> 						pEntry->FileSize = SwapBBBB(pEntry->FileSize);
550,552c468,470
< 					pEntry++;
< 				}		
<                 pEntry = (DIRENTRY*)sector_buffer;
---
> 					pEntry++;
> 				}		
>                 pEntry = (DIRENTRY*)sector_buffer;
605c523
<                         if ((extension[0] == '*') || (strncmp((const char*)&pEntry->Name[8], extension, 3) == 0) || (options & SCAN_DIR && pEntry->Attributes & ATTR_DIRECTORY))
---
>                         if (extension[0] == '*' || strncmp((const char*)&pEntry->Name[8], extension, 3) == 0 || options & SCAN_DIR && pEntry->Attributes & ATTR_DIRECTORY)
858c776
<                                     x = tolower(pEntry->Name[0]) >= tolower(mode) && is_file;
---
>                                     x = pEntry->Name[0] >= mode && is_file;
860c778
<                                     x = tolower(pEntry->Name[0]) >= tolower(mode) || is_file;
---
>                                      x = pEntry->Name[0] >= mode || is_file;
985c903
<     /*
---
> 
988c906
<     */
---
> 
1064,1065c982,992
< //        file->cluster = fat32 ? fat_buffer.fat32[i] & 0x0FFFFFFF: fat_buffer.fat16[i]; // get FAT link
<         file->cluster = fat32 ? SwapBBBB(fat_buffer.fat32[i]) & 0x0FFFFFFF : SwapBB(fat_buffer.fat16[i]); // get FAT link for 68000 
---
> //        file->cluster = fat32 ? fat_buffer.fat32[i] : fat_buffer.fat16[i]; // get FAT link
>         file->cluster = fat32 ? SwapBBBB(fat_buffer.fat32[i]) : SwapBB(fat_buffer.fat16[i]); // get FAT link for 68000 
> //        if (fat32)
> //        {
> //			file->cluster = ((file->cluster>>24)&0xFF)|((file->cluster>>8)&0xFF00)|((file->cluster<<8)&0xFF0000)|((file->cluster<<24)&0x0F000000); // for 68000 
> //		}
> //		else
> //        {
> //			file->cluster = ((file->cluster>>8)&0xFF)|((file->cluster<<8)&0xFF00); // for 68000 
> //		}
> 
1072c999
< unsigned char FileSeek(fileTYPE *file, unsigned long offset, unsigned long origin)
---
> unsigned char FileSeek(fileTYPE *file, unsigned long offset)
1075d1001
< // origin can be set to SEEK_SET or SEEK_CUR
1080,1082d1005
<     if (origin == SEEK_CUR)
<         offset += file->sector;
< 
1095d1017
<     
1119,1132c1041
< //        file->cluster = fat32 ? SwapBBBB(fat_buffer.fat32[i]) & 0x0FFFFFFF : SwapBB(fat_buffer.fat16[i]); // get FAT-link for 68000
<         if (fat32)
<         {
<             file->cluster = SwapBBBB(fat_buffer.fat32[i]) & 0x0FFFFFFF; // get FAT32 link
<             if (file->cluster == 0x0FFFFFFF) // FAT32 EOC
<                 return 0;
<         }
<         else
<         {
<             file->cluster = SwapBB(fat_buffer.fat16[i]); // get FAT16 link
<             if (file->cluster == 0xFFFF) // FAT16 EOC
<                 return 0;
<         }
< 
---
>         file->cluster = fat32 ? SwapBBBB(fat_buffer.fat32[i]) & 0x0FFFFFFF : SwapBB(fat_buffer.fat16[i]); // get FAT-link for 68000
1142c1051
< unsigned char FileRead(fileTYPE *file, unsigned char *pBuffer)
---
> unsigned char FileRead(fileTYPE *file)
1150c1059
<     if (!MMC_Read(sb, pBuffer)) // read sector from drive
---
>     if (!MMC_Read(sb, sector_buffer)) // read sector from drive
1157,1183c1066
< unsigned char FileReadEx(fileTYPE *file, unsigned char *pBuffer, unsigned long nSize)
< {
<     unsigned long sb;
<     unsigned long bc; // block count of single multisector read operation
< 
<     while (nSize)
<     {
<         sb = data_start;                         // start of data in partition
<         sb += cluster_size * (file->cluster-2);  // cluster offset
<         sb += file->sector & ~cluster_mask;      // sector offset in cluster
<         bc = cluster_size - (file->sector & ~cluster_mask); // sector offset in the cluster
<         if (nSize < bc)
<             bc = nSize;
< 
<         if (!MMC_ReadMultiple(sb, pBuffer, bc))
<             return 0;
< 
<         if (!FileSeek(file, bc, SEEK_CUR))
<             return 0;
< 
<         nSize -= bc;
<     }
< 
<     return 1;
< }
< 
< unsigned char FileWrite(fileTYPE *file,unsigned char *pBuffer)
---
> unsigned char FileWrite(fileTYPE *file)
1191c1074
<     if (!MMC_Write(sector, pBuffer)) // write sector from drive
---
>     if (!MMC_Write(sector, sector_buffer)) // write sector from drive
